1.渲染组件

<!-- const VueComponent = {
    data() {
        return { name: "jw", age: 30 };
    },
    render() {
        console.log("render");
        setTimeout(() => {
            this.age++;
            this.age++;
        }, 1000);
        return h("div", [
            h(Text, "my name is" + this.name),
            h("a", this.age),
        ]);
    },
}; -->

//组件由两个虚拟节点组成 h(VueComponent) = vnode 产生的是组件的内的虚拟节点，
//render 函数返回的虚拟节点，这个虚拟节点才是最终要渲染的内容 = subTree(vnode)
render(h(VueComponent), app);内部会调用组件的 render 方法，拿到返回值渲染到容器(app)中

2.template 会渲染成 render 函数

3.vue 组件是怎么渲染和更新的？
会有一个 instance 记录者当前组件的状态等信息，组件里的 data 返回的对象会包在 Reactive 里面,而组件的 render 函数，会在 vue 内部执行，放到 effect(ReactiveEffect)里面,这样 data 变化，render 会自动执行（render 函数执行的返回值叫 subTree），执行的时候区分是第一次挂载还是更新。

4.更新批处理
通过事件循环机制，延迟更新操作，先走同步代码，再走微任务（更新操作），更新操作在微任务中执行。

5. vue 中 attrs 是非响应式的，props 是响应式的。
<!-- render(h(VueComponent, { a: 1, b: 2, name: "jw", age: 30 }), app); -->

//属性 attrs(非响应式的) + props(响应式的) props 会被 reactive 包裹
//所有属性 - propsOptions = attrs
//vue 会对所有传入组件的属性根据组件内部定义的 props 做区分，组件定义的 props 是 props，其他是 attrs。attrs 是非响应式的，props 是响应式的。

<!-- const VueComponent = {
        props: {
            //defineProps
            name: String,
            age: Number,
        },
        data() {
            return { x: 1, y: 2 };
        },
        render(proxy) {
            return h("div", [
            h(Text, "my name is" + this.$attrs.a),
            h("a", this.age),
            ]);
        },
    };
-->

6.vue 中组件实例 instance 会有一个代理对象，instance 会做一个 proxy，用来代理 props，attrs，data。让用户更方便的使用。
譬如：使用 proxy.name 或者 this.name,使用 proxy.$attrs.a 或者 this.$attrs.a，使用 proxy.$slots.x 或者 this.$slots.x => 中间会对 instance 做一个代理 => 本质上会会去 instance 上去取(instance.data、instance.props、instance.attrs)
$attrs: (instance) => instance.attrs,
$slots: (instance) => instance.slots,

<!-- const VueComponent = {
        props: {
            //defineProps
            name: String,
            age: Number,
        },
        data() {
            return { x: 1, y: 2 };
        },
        render(proxy) {
            return h("div", [
            // h(Text, "my name is" + this.$attrs.a),
            // h("a", this.age),
            h("a", proxy.name),
            ]);
        },
    };
render(h(VueComponent, { a: 1, b: 2, name: "jw", age: 30 }), app);
-->

7.组件更新有三种方式：(状态、属性、插槽)
状态就是组件中的 data: 因为一个组件会创建一个 effect,组件的 render 会放到 effect 里面回调函数，组件的 data 变化,会触发 effect 里面回调函数再次执行，这样组件的 render 会重新执行。
属性就是 props，(props 本身就是响应式的)：父组件给子组件传入了 props，子组件使用了父组件传过来的 props，这样子组件就会记住当前的 effect(也就就是子组件的 render),后面父组件传入的 props 发生变化，子组件的 render(effect)会重新执行,但是在重新执行之前，要对更新前和更新后的 props 做一个简单的 diff，这个时候我们需要更新组件上的 instance.props，就可以达到页面更新的效果。

8.setup:每个组件只会执行一次，可以放入我们的 compositionApi:reactive,ref 等等
在组件里展示 dom，可以使用 render 函数，也可以使用 setup 返回一个函数。
setup 每个组件只执行一次

<!-- const VueComponent = {
        setup(props, { emit, attrs, expose, slots }) {
            //提供渲染逻辑
            const a = ref(1);
            setTimeout(() => {
                a.value = 2;
            }, 1000);
            return () => {
                return h("div", a.value);
            };
        },
    };
    render(h(VueComponent, {}), app);
-->

setup 可以返回函数，也可以返回对象：看 setup 的返回值，如果返回值是对象，就会作为组件的状态；函数就是组件中 dom(template)

<!-- const VueComponent = {
        setup(props, { emit, attrs, expose, slots }) {
            //提供渲染逻辑
            const a = ref(1);
            setTimeout(() => {
                a.value = 2;
            }, 1000);
            return {
                a: a,
            };
        },
        render(proxy) {
            return h("div", proxy.a);
        },
    };
-->

vue 内部会执行 setup,把当前实例的 props 和 setupContext 传进去进去，如果 setup 的返回值是函数，那么返回值会赋值给 instance.render;
如果 setup 的返回值是对象，那么返回值会首先通过 proxyRef 做脱 ref,之后赋值给 instance.setupState,后续在 render(dom 渲染)函数中可以取到 setupState(通过 proxy 取)
render(proxy) {
//return h("div", proxy.a);
},

<!-- const setupResult = setup(instance.props, setupContext);
    if (isFunction(setupResult)) {
        instance.render = setupResult;
    } else {
        instance.setupState = proxyRefs(setupResult); //将返回的值做脱ref
    }
-->

9.setupContext(emit, attrs, expose, slots)，setupContext 是 setup 的第二个参数
9.1 slots 插槽在 h 中是放到第三个参数 children 里的，vue 内部会把插槽放到 instance.slots 上(instance.slots = children),当在组件中使用插槽的时候，会从 instance 上取 slots
slots = instance.slots

<!-- const RenderComponent = {
        setup(props, { emit, attrs, expose, slots }) {
            return (proxy) => {
                return h(Fragment, [slots.footer("fff"), slots.header("hhh")]);
            };
        },
    };

    //RenderComponent
    // <template>
    //  <slot name="avatar">
    //    <slot name="footer"></slot>
    //    <slot name="header"></slot>
    // </template>

    const VueComponent = {
        setup(props, { emit, attrs, expose, slots }) {
            return (proxy) => {
                return h(RenderComponent, null, {
                    header: (t) => h("header", "header" + t),
                    footer: (t) => h("footer", "footer" + t),
                });
            };
        },
    };

    //VueComponent
    // <template>
    //   <RenderComponent>
    //     <template v-slot:header>
    //       header
    //     </template>
    //     <template v-slot:footer>
    //       footer
    //     </template>
    //   </RenderComponent>
    // </template>

    render(h(VueComponent, {}), app);
-->

9.2 attrs: instance.attrs,
9.3 emit: 实际上就是 vue 内部通过 emit 中的方法名去取当前组件实例 instance.props 匹配，找到这个方法执行

<!-- const VueComponent = {
        setup(props, { emit, attrs, expose, slots }) {
        return (proxy) => {
            return h(
                "button",
                { onClick: () => emit("myEvent", 100) },
                    "点我啊"
                );
            };
        },
    };
    render(h(VueComponent, { onMyEvent: (value) => alert(value) }), app);
-->

9.4 expose:是一个函数，就是给当前组件实例 instance 赋值 exposed
expose(value) {
//instance.exposed = value;
},
