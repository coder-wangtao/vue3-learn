1.h 方法：根据 type, propsOrChildren, children 创建出虚拟 dom(vnode)(一个对象)，本质上就是对参数做处理，调用 createVnode，createVnode 就是创建一个 vnode 对象
render 方法：使用内置的渲染器()来进行渲染,内置是 dom 渲染器（默认采用的是 dom api 进行渲染），render = (vnode, container)={}。
createRenderer 方法：我们可以自己创建渲染器（让我们自己提供渲染方法），createRenderer(renderOptions).render(vnode, container)，renderOptions 就是自定义的渲染器对象

//runtime-dom 的作用就是提供 dom api(提供一系列 dom 的操作的 api 方法)

//runtime-dom ->(依赖) runtime-core ->(依赖) reactivity

runtime-dom 的作用主要是提供一些 dom Api,把 dom Api 传给底层 runtime-core

处理@click 的时候：先转换成 onClick，之后变成 click,变成 click 的过程中通过 createInvoker 创建一个 invoker 函数，这个函数调用 click 的回调，
//const invoker = (e) => invoker.value(e);在这个 invoker 添加一个属性 value = 调用 click 的回调，如果要修改这个回调，直接修改 invoker.value 即可，不需要重复创建

<!-- function createInvoker(value) {
  const invoker = (e) => invoker.value(e);
  invoker.value = value; //更改invoker中的value属性，可以修改对应的调用函数
  return invoker;
} -->

2.vnode 中有一个属性 shapeFlag 对元素形狀的判断,譬如:div 子元素下面是一个数组(多个元素)，
shapeFlag 就等于 ELEMENT|ARRAY_CHILDREN=17 （ELEMENT = 1 === 1， ARRAY_CHILDREN = 1 << 4 === 16）

  <!-- const ele1 = h(
    "div",
    { style: { color: "red" } },
    h("div", "a1"),
    h("div", "b1"),
    h("div", "c1")
  ); -->

譬如:div 子元素下面是一个文本元素，shapeFlag 就等于 ELEMENT | TEXT_CHILDREN（ELEMENT = 1 === 1， ARRAY_CHILDREN = 1 << 3 === 8）

<!-- const ele2 = h("div", { style: { color: "red" } }, "1"); -->

之后通过&运算判断，譬如：shapeFlag & TEXT_CHILDREN > 0 说明说明儿子是文本，shapeFlag & ARRAY_CHILDREN > 0 说明说明儿子一个数组，

3.vnode 中的 el
第一次渲染的时候，我们让虚拟节点和真实 dom 创建关联 vnode.el = 真实 dom
第二次渲染 null，就可以把第一次渲染 vnode.el = 真实 dom 拿出来，删掉
或者第二次渲染新的 vnode，可以和上一次的 vnode 做比对比，之后更新对应的 el 元素。可以后续再复用这个 dom 元素

4.关于 h 和 createVnode
用 jsx 写的代码，编译后使用 h
但是用 template 写的代码，源码全部编译成 createVnode，为了做靶向更新。

5.vue 中判断两个 vnode 是否一致，可以复用？
两个 vnode 的 type 和 key 都一致

6.vue 中的更新(vnode)dom
//1.第一次渲染时有，第二次更新时没有，直接调用 runtime-dom 里的删除方法删除 dom
//2.第一次渲染时有,第二次更新时也有，判断两次 vnode 是否可以复用，不能复用，删除第一次渲染时的 dom，第二次更新时 dom 走挂载逻辑。能复用，比较两次的 vnode，复用 dom。
//2.1 复用的情况：复用 dom[let el = (n2.el = n1.el),n2 是新的 vnode,n1 是旧的 vnode]，比较两次的属性，修改属性，对比儿子(children)。
//2.2 对比两次 vnode 的 children
//2.2.1 新的是文本，老的是数组，移除老的，把新的文本塞到父元素里
//2.2.2 新的是文本，老的也是文本，拿到父元素把文本替换
//2.2.3 新的是数组，老的也是数组，走全量 diff 算法
//2.2.4 老的树数组，新的是空，移除老的
//2.2.5 老的是文本，新的是空，移除老的
//2.2.6 老的是文本，新的是数组，移除老的，把新的新的数组塞到父元素里
//3.第一次渲染时没有，第二次更新时有，第二次更新时 dom 走挂载逻辑

7. 全量 diff 算法（有 key 的情况）：
   //1.比较两个儿子的差异，更新 el(append removeChild insertBefore)
   //2.减少比对范围，先从头开始比，再从尾部开始比，确定不一样的范围
   //3.新的多老的少，el.appendChild/insertBefore 插入新的；老的多新的少，删掉老的多的(找到它的父元素刪掉 当前多的元素)
   //4.以上确认不变换的节点，并且对插入和删除都做了处理，然后再进行特殊处理（处理中间变化的 vnode）
   //5.用新的 children 做一个映射表(遍历新的 children 的范围，children[i]的 key 作为 key，children 的索引作为 value)用于快速查找，
   然后再遍历看老的元素是否在新的里面还有，没有就删除，有的话就更新(更新属性和递归儿子)。
   //6.此时 vnode 目前是老的 children 的顺序，需要调整顺序
   //7.对新的剩下的需要更新的范围做倒序遍历，找到更新范围外的第一个 vnode(是在老的 el.children 做插入操作操作)，从后往前插入,如果老的在新的里面存在，就用老的插入,如果老的在新的里面不存在，就用创建一个新的插入。
