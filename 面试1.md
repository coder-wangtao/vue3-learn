区分编译时和运行时
编译时：将模版编译成虚拟 dom(在构建时进行编译性能更高，不需要再运行时进行编译，而且 vue3 在编译时做了很多优化)

vue3 注重模块上的拆分 vue3 中的模块之间耦合度低，模块可以独立使用（拆分模块）

Vue 2 的全局 API（如 Vue.nextTick）会导致全部相关代码被打包，即使未被使用。
Vue 3 将全局 API 改为通过 ES 模块导出，未被引用的 API 会被 Tree-Shaking 移除。

// Vue 2（全局 API 无法被优化）
import Vue from 'vue';
Vue.nextTick(() => {});

// Vue 3（按需引入）
import { nextTick } from 'vue';
nextTick(() => {});

通过构建工具 Tree-shaking 机制实现按需引入，减少用户打包后的体积 (组合式 API)，支持自定义 Hook，可以像扩展器一样封装复杂逻辑。

vue3 允许自定义渲染器，扩展能力更强。（自定义渲染器就是把 Vue 的虚拟 DOM 渲染到 非 DOM 的目标， 基于：@vue/runtime-core）

pnpm install vue -w //安装到项目的根目录

pnpm install @vue/shared --filter @vue/reactivity //把@vue/shared 安装到@vue/reactivity，但是@vue/shared 是第三方包
pnpm install @vue/shared --workspace --filter @vue/reactivity //把@vue/shared 安装到@vue/reactivity，@vue/shared 是当前目录下

<!-- {
  "name": "@vue/compiler-core",
  "version": "1.0.0",
  "module": "dist/compiler-core.esm-bundler.js",   //通过import引入的方式 找dist/compiler-core.esm-bundler.js
  "unpkg": "dist/compiler-core.global.js",  //直接在浏览器里使用 window.的方式
  "buildOptions": {
    "name": "VueCompilerCore",
    "formats": [
      "esm-bundler",   //通过import引入的方式，打包到一起的 通过 import { xxx } from 'vue' 导入，并由打包工具做 Tree-shaking。
      "esm-browser",  //通过import引入的方式，浏览器环境,无需打包工具，适合 CDN 或小型项目。
      "cjs",   //commonjs
      "global"  //window直接在浏览器里使用 window.的方式
    ]
  },
  "dependencies": {
    "@vue/shared": "workspace:*"
  }
} -->

我们在代码中引用 vue,本质上 vue -> runtime-dom -> runtime-core -> reactivity (runtime-dom、runtime-core 是渲染器 renderer)
我们写的 vue 组件 -> render 函数，是由编译器(compiler)完成

CompositionApi
CompositionApi 在用户编写复杂业务逻辑不会出现反复横跳的问题
CompositionApi 不存在 this 指向不明确的问题
CompositionApi 对 tree-shaking 更加友好，代码也更容易压缩
CompositionApi 提取公共逻辑非常方便

1.reactive

//get：取值 让响应式属性 和 effect 映射起来（依赖收集:收集对象上的属性，和 effect 关联在一起

let res = Reflect.get(target, key, receiver);

vue3.4 /

<!-- 搞一个weakMap，防止内存泄漏
{
  {name:'jw',age:30}:{
    name:{effect1,effect2},
    age:{effect1}
  }
} -->

//双向记忆
effect1.deps = [Map{}[name],Map{}[age]]
effect2.deps = [Map{}[name]]

set：触发更新的时候找到属性，让对应的 effect 重新执行（触发更新）
let result = Reflect.set(target, key, value, receiver);

<!-- effect(() => {
TODO:一个 effect 回调函数对应一个 ReactiveEffect，通过一个变量activeEffect，对象中属性key1,key2
}) -->

递归的情况不用考虑多层，只需要考虑两层就好，儿子在执行的时候保存父亲，执行完返回父亲就好

<!-- effect(() => {
      console.log(state.name)
      effect(() => {
        console.log(state.name)
      })
      console.log(state.age)
    }) -->

针对两次执行 effect 收集依赖不一致的情况下：会做一个 diff
第一次：flag: effect,name:effect
第二次：flag: effect,age:effect
//会把上一次的删掉，能复用的就复用，复用不了的就删除
如果之前的依赖比较多，后面的依赖比较少，会在执行完 run 方法后（try finally）把多的依赖删除掉

<!-- effect(() => {
  app.innerHTML = state.flag ? state.name : state.age;
}) -->

<!-- setTimeout(() => {
  state.flag = false;
}, 1000); -->

//effect 做 AOP 编程(自定义调度器)

 <!-- let runner = effect(
        () => {
          app.innerHTML = state.flag ? state.name : state.age;
        },
        {
          //state.flag改变会触发scheduler的执行
          scheduler: () => {
            console.log("数据更新了，不重新渲染，走自己的逻辑"); //AOP、批处理（更新两次，只调一次）
            //runner就是执行effect的第一个参数（用户自定义的回调函数）
            runner();//fn执行一次
          },
        }
      ); -->

2.ref：ref({}) 直接走 reactive
new 一个 类 对 value 做 get value() /set value()方法
get value() 收集依赖 dep {ReactiveEffect => 2}
set value() 触发依赖 dep => 找到 ReactiveEffect，触发 ReactiveEffect 的 scheduler 方法 => 触发用户自定义的回调函数

<!-- class RefImpl {
      public __v_isRef = true; //ref标识
      public _value; //用来保存ref的值
      public dep; //用于收集对应的effect
      constructor(public rawValue) {
        this._value = toReactive(rawValue);
      }
      get value() {
        //收集依赖(effect)
        trackRefValue(this);
        return this._value;
      }

      set value(newValue) {
        //触发依赖(effect)
        if (newValue !== this.rawValue) {
          this.rawValue = newValue;
          this._value = newValue;
          triggerRefValue(this);
        }
      }
} -->

3.toRef：是将 reactive 对象变成 ref（本质上还是基于 proxy 来取值和设置值）,防止拆包的时候丧失响应式： console.log({ ...state });

<!-- class ObjectRefImpl {
      public __v_isRef = true; //增加ref标识
      constructor(public _object, public _key) {}

      get value() {
        return this._object[this._key];
      }

      set value(newValue) {
        this._object[this._key] = newValue;
      }
    } -->

4.toRefs：挨个属性调 toRef，防止拆包的时候丧失响应式,返回一个对象，里面每个属性都调用 toRef （本质上还是基于 proxy 来取值和设置值）： console.log({ ...state });

5.proxyRefs:用 prox 做代理，template 中会调 proxyRefs 自动脱 ref。

<!-- export function proxyRefs(objectWithRef) {
      return new Proxy(objectWithRef, {
        get(target, key, receiver) {
          let r = Reflect.get(target, key, receiver);
          return r.__v_isRef ? r.value : r; //自动脱ref
        },
        set(target, key, value, receiver) {
          const oldValue = target[key];

          if (oldValue.__v_isRef) {
            oldValue.value = value; //如果老值是ref,需要给ref赋值
            return true;
          }
          return Reflect.set(target, key, value, receiver);
        },
      });
    } -->

6.数据发生变化 => effect 的调度函数
